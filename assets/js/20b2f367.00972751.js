"use strict";(self.webpackChunkgitopssecuritychampion=self.webpackChunkgitopssecuritychampion||[]).push([[733],{2352:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>n,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"resources/restrict-repository-access/restrictRepositoryAccess","title":"Restrict Repository Access","description":"Overview","source":"@site/docs/resources/restrict-repository-access/README.md","sourceDirName":"resources/restrict-repository-access","slug":"/restrictRepositoryAccess","permalink":"/GitOpsSecurityChampion/restrictRepositoryAccess","draft":false,"unlisted":false,"editUrl":"https://github.com/CycodeLabs/GitOpsSecurityChampion/blob/main/docs/resources/restrict-repository-access/README.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"slug":"/restrictRepositoryAccess","id":"restrictRepositoryAccess","sidebar_position":4},"sidebar":"resources","previous":{"title":"Network Policies Enforcement","permalink":"/GitOpsSecurityChampion/networkPoliciesEnforcement"},"next":{"title":"Strict RBAC Policies","permalink":"/GitOpsSecurityChampion/strictRBACPolicies"}}');var r=t(4848),o=t(8453);const n={slug:"/restrictRepositoryAccess",id:"restrictRepositoryAccess",sidebar_position:4},c="Restrict Repository Access",a={},l=[{value:"Overview",id:"overview",level:2},{value:"Why It\u2019s Important",id:"why-its-important",level:2},{value:"Implementation Steps",id:"implementation-steps",level:2}];function p(e){const s={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"restrict-repository-access",children:"Restrict Repository Access"})}),"\n",(0,r.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(s.p,{children:"In a GitOps workflow, repositories that store Kubernetes manifests, Helm charts, and other configuration files are essential for managing infrastructure. These repositories should be kept private, with access strictly limited to authorized individuals or teams. Allowing outside collaborators or broad access increases the risk of unauthorized changes, whether accidental or malicious."}),"\n",(0,r.jsx)(s.h2,{id:"why-its-important",children:"Why It\u2019s Important"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Protect Sensitive Data:"})," Configuration repositories often contain sensitive infrastructure details that must remain secure. Unauthorized access can expose sensitive information or lead to misconfigurations that compromise the system's security."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Enforce Better Access Control:"})," By separating configuration repositories from source code repositories (as discussed in ",(0,r.jsx)(s.a,{href:"/GitOpsSecurityChampion/separatingConfig",children:"Separating Config Vs. Source Code Repositories"}),"), you can grant access based on roles and needs, further upholding the principle of least privilege."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Keep Repositories Private:"})," Ensure that GitOps configuration repositories are set to private and restrict any public access."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Restrict Collaborator Access:"})," Limit repository access to a small, trusted group of individuals or specific teams, such as the DevOps team, responsible for maintaining the infrastructure."]}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>n,x:()=>c});var i=t(6540);const r={},o=i.createContext(r);function n(e){const s=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);