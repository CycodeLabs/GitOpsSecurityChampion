"use strict";(self.webpackChunkgitopssecuritychampion=self.webpackChunkgitopssecuritychampion||[]).push([[278],{7403:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"README","title":"GitOps Security Champion","description":"GitOpsSecurityChampion aims to provide security guidelines along with best practices and resources to secure GitOps workflows. GitOps is a modern approach to managing infrastructure and applications through version-controlled configuration files stored in a Git repository. By following security best practices, organizations can ensure the integrity, confidentiality, and availability of their GitOps environments.","source":"@site/docs/README.md","sourceDirName":".","slug":"/","permalink":"/","draft":false,"unlisted":false,"editUrl":"https://github.com/CycodeLabs/GitOpsSecurityChampion/blob/main/docs/README.md","tags":[],"version":"current","frontMatter":{}}');var r=t(4848),n=t(8453);const o={},a="GitOps Security Champion",c={},l=[{value:"Best Practices",id:"best-practices",level:2},{value:"Cluster Separation",id:"cluster-separation",level:3},{value:"Separating Config Vs. Source Code Repositories",id:"separating-config-vs-source-code-repositories",level:3},{value:"Network Policies Enforcement",id:"network-policies-enforcement",level:3},{value:"Strict RBAC Policies",id:"strict-rbac-policies",level:3},{value:"Restrict Repository Access",id:"restrict-repository-access",level:3},{value:"Branch Protection Rules",id:"branch-protection-rules",level:3},{value:"Use Password Management Tool",id:"use-password-management-tool",level:3},{value:"SLSA Provenance Verification",id:"slsa-provenance-verification",level:3}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"gitops-security-champion",children:"GitOps Security Champion"})}),"\n",(0,r.jsx)(s.p,{children:"GitOpsSecurityChampion aims to provide security guidelines along with best practices and resources to secure GitOps workflows. GitOps is a modern approach to managing infrastructure and applications through version-controlled configuration files stored in a Git repository. By following security best practices, organizations can ensure the integrity, confidentiality, and availability of their GitOps environments."}),"\n",(0,r.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Best Practice"}),(0,r.jsx)(s.th,{children:"Priority"}),(0,r.jsx)(s.th,{children:"Description"}),(0,r.jsx)(s.th,{children:"Link"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Cluster Separation"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Host the GitOps tool on a separate cluster to safeguard it from application-level compromises."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/clusterSeparation",children:"Details"})})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Separating Config Vs. Source Code Repositories"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Store Kubernetes manifests in a separate repo from application code to ensure cleaner versioning and access control."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/separatingConfig",children:"Details"})})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Network Policies Enforcement"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Ensure network policies limit access only to necessary resources and are enforced correctly."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/networkPoliciesEnforcement",children:"Details"})})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Strict RBAC Policies"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Limit permissions to the GitOps system, ensure agents have restricted access, and use admission control for policy enforcement."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/strictRBACPolicies",children:"Details"})})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Restrict Repository Access"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Keep the configuration repository private, and grant access only to authorized teams or individuals."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/restrictRepositoryAccess",children:"Details"})})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Branch Protection Rules"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Enforce rules for code reviews, CI/CD checks, and restricted access to critical branches to ensure only authorized changes are deployed."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/branchProtectionRules",children:"Details"})})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Use Password Management Tool"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Sensitive data should never be kept in plain text and should always be stored in a proper secret management tool."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/passwordManagement",children:"Details"})})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"SLSA Provenance Verification"}),(0,r.jsx)(s.td,{children:"Gold"}),(0,r.jsx)(s.td,{children:"Users should always verify the SLSA Provenance produced by the GitOps supplier. For example, ArgoCD publishes a signed SLSA Provenance that should be verified by end users to ensure GitOps integrity."}),(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/slsaProvenanceVerification",children:"Details"})})]})]})]}),"\n",(0,r.jsx)(s.h3,{id:"cluster-separation",children:"Cluster Separation"}),"\n",(0,r.jsx)(s.p,{children:"Cluster separation in GitOps means isolating the GitOps control plane on its own dedicated cluster, separate from application clusters. This isolation minimizes the impact of potential security incidents: if an application cluster is compromised, it won\u2019t provide an attacker direct access to the GitOps management system. This separation reduces risks, enhances control, and improves overall security posture."}),"\n",(0,r.jsx)(s.h3,{id:"separating-config-vs-source-code-repositories",children:"Separating Config Vs. Source Code Repositories"}),"\n",(0,r.jsx)(s.p,{children:"In GitOps workflows, it is recommended to store configuration (such as Kubernetes manifests) in a separate Git repository from the application source code. This separation provides a cleaner distinction between application code and configuration, making it easier to audit, manage access, and avoid unnecessary CI/CD rebuilds due to configuration-only changes."}),"\n",(0,r.jsx)(s.h3,{id:"network-policies-enforcement",children:"Network Policies Enforcement"}),"\n",(0,r.jsx)(s.p,{children:"Limit access in your GitOps environment by enforcing network policies, allowing only necessary resources access to each other. Even if network policies are configured, you must verify they\u2019re enforced."}),"\n",(0,r.jsx)(s.h3,{id:"strict-rbac-policies",children:"Strict RBAC Policies"}),"\n",(0,r.jsx)(s.p,{children:"To ensure a secure GitOps environment, strict Role-Based Access Control (RBAC) policies should be enforced. Permissions to manage the GitOps system should be granted only to specific personnel or teams who need it, such as the DevOps team, while most developers should not have this level of access. The GitOps agent should be restricted to managing only specific namespaces and clusters, defined through an allowed list. Additionally, admission control should be used to ensure that the configurations deployed by GitOps meet your organization\u2019s security and compliance policies. By following these practices, you can minimize risk, prevent unauthorized access, and ensure that only compliant configurations are deployed."}),"\n",(0,r.jsx)(s.h3,{id:"restrict-repository-access",children:"Restrict Repository Access"}),"\n",(0,r.jsx)(s.p,{children:"In a GitOps workflow, repositories that store configuration files such as Kubernetes manifests and Helm charts are crucial to infrastructure management. These repositories should be kept private and must not accept outside collaborators. Only a small number of authorized individuals, typically from specific teams such as DevOps, should have access to these repositories. This limited access reduces the risk of accidental or malicious changes that could compromise the infrastructure."}),"\n",(0,r.jsx)(s.h3,{id:"branch-protection-rules",children:"Branch Protection Rules"}),"\n",(0,r.jsxs)(s.p,{children:["Branch protection rules are essential for safeguarding critical configuration repositories used in GitOps workflows. These rules ensure that code changes cannot be pushed directly to important branches like ",(0,r.jsx)(s.code,{children:"main"})," or ",(0,r.jsx)(s.code,{children:"production"})," without passing through a controlled process, such as code reviews and automated testing. By enforcing these rules, you ensure that only authorized changes are deployed to your infrastructure."]}),"\n",(0,r.jsx)(s.h3,{id:"use-password-management-tool",children:"Use Password Management Tool"}),"\n",(0,r.jsx)(s.p,{children:"Sensitive data such as passwords, API keys, and other secrets should never be kept in plain text in Git repositories. Instead, use a password management tool to securely store and manage these secrets. This practice ensures that sensitive information is protected from unauthorized access and reduces the risk of accidental exposure."}),"\n",(0,r.jsx)(s.h3,{id:"slsa-provenance-verification",children:"SLSA Provenance Verification"}),"\n",(0,r.jsx)(s.p,{children:"Users should always verify the SLSA Provenance produced by the GitOps supplier. For example, ArgoCD publishes a signed SLSA Provenance that should be verified by end users to ensure GitOps integrity."})]})}function h(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>a});var i=t(6540);const r={},n=i.createContext(r);function o(e){const s=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(n.Provider,{value:s},e.children)}}}]);