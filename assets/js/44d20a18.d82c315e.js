"use strict";(self.webpackChunkgitopssecuritychampion=self.webpackChunkgitopssecuritychampion||[]).push([[595],{9896:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"resources/cluster-separation/clusterSeparation","title":"Cluster Separation","description":"Overview","source":"@site/docs/resources/cluster-separation/README.md","sourceDirName":"resources/cluster-separation","slug":"/clusterSeparation","permalink":"/GitOpsSecurityChampion/clusterSeparation","draft":false,"unlisted":false,"editUrl":"https://github.com/CycodeLabs/GitOpsSecurityChampion/blob/main/docs/resources/cluster-separation/README.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"slug":"/clusterSeparation","id":"clusterSeparation","sidebar_position":1},"sidebar":"resources","next":{"title":"Network Policies Enforcement","permalink":"/GitOpsSecurityChampion/networkPoliciesEnforcement"}}');var n=s(4848),r=s(8453);const o={slug:"/clusterSeparation",id:"clusterSeparation",sidebar_position:1},a="Cluster Separation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Why It\u2019s Important",id:"why-its-important",level:2},{value:"Implementation Steps",id:"implementation-steps",level:2}];function p(e){const t={h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"cluster-separation",children:"Cluster Separation"})}),"\n",(0,n.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(t.p,{children:"Cluster separation in GitOps involves hosting the GitOps control plane on a distinct Kubernetes cluster, separate from the application clusters. By isolating the GitOps tool (e.g., ArgoCD, FluxCD) from the clusters where applications run, you create a security boundary that limits the risk of an attacker gaining control over the GitOps pipeline if they compromise an application cluster."}),"\n",(0,n.jsx)(t.h2,{id:"why-its-important",children:"Why It\u2019s Important"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Security Isolation:"})," A compromised application cluster won\u2019t grant direct access to the GitOps tool, reducing the potential impact of the breach."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Enhanced Control:"})," A dedicated GitOps cluster allows for stricter access control and better monitoring of the deployment process."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Reduced Attack Surface:"})," Keeping the GitOps cluster more secure and isolated from publicly exposed application clusters reduces its vulnerability to network-based attacks."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Set Up a Dedicated GitOps Cluster:"})," Deploy your GitOps tool in a separate Kubernetes cluster, isolated from production and staging clusters."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Enforce Network Isolation:"})," Use network policies to prevent the application clusters from directly communicating with the GitOps cluster, allowing access only for necessary pull and deployment operations."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Monitor for Anomalies:"})," Set up logging and monitoring specifically for the GitOps cluster to alert on any suspicious activities."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var i=s(6540);const n={},r=i.createContext(n);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);