"use strict";(self.webpackChunkgitopssecuritychampion=self.webpackChunkgitopssecuritychampion||[]).push([[2],{1452:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"resources/gitops-manifest-segregation/gitOpsManifestSegregation","title":"GitOps Manifest Segregation","description":"Overview","source":"@site/docs/resources/gitops-manifest-segregation/README.md","sourceDirName":"resources/gitops-manifest-segregation","slug":"/gitOpsManifestSegregation","permalink":"/GitOpsSecurityChampion/gitOpsManifestSegregation","draft":false,"unlisted":false,"editUrl":"https://github.com/CycodeLabs/GitOpsSecurityChampion/blob/main/docs/resources/gitops-manifest-segregation/README.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"slug":"/gitOpsManifestSegregation","id":"gitOpsManifestSegregation","sidebar_position":2},"sidebar":"resources","previous":{"title":"Cluster Separation","permalink":"/GitOpsSecurityChampion/clusterSeparation"},"next":{"title":"Network Policies Enforcement","permalink":"/GitOpsSecurityChampion/networkPoliciesEnforcement"}}');var s=n(4848),o=n(8453);const r={slug:"/gitOpsManifestSegregation",id:"gitOpsManifestSegregation",sidebar_position:2},a="GitOps Manifest Segregation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Why It\u2019s Important",id:"why-its-important",level:2},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function p(e){const i={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"gitops-manifest-segregation",children:"GitOps Manifest Segregation"})}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"Separate the GitOps Kubernetes configurations (e.g., manifests) into a dedicated Git repository, distinct from your GitOps managed application source code. Isolating application configuration from the codebase enhances deployment control, simplifies auditing, and prevents unintended CI/CD pipeline triggers due to minor configuration changes."}),"\n",(0,s.jsx)(i.h2,{id:"why-its-important",children:"Why It\u2019s Important"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Access Control and Security:"})," Developers focused on application code shouldn't necessarily have access to production configuration repositories. A separate repository ensures that only authorized personnel can modify production configurations"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Cleaner Audit Logs:"})," Keeping configuration in a separate repository ensures that commit history only reflects changes to deployment specs and configurations, making audit logs more focused and useful."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Managing Complex Applications:"})," For multi-service applications (e.g., ELK Stack, Kafka with ZooKeeper), separating manifests into their own repository enables independent versioning and release cycles for each service while maintaining cohesive deployments."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Avoiding Infinite CI/CD Loops:"})," Mixing configuration changes with application code in a single repository can lead to unwanted CI/CD pipeline triggers, creating continuous rebuilds. A dedicated configuration repository avoids this issue by preventing triggers for configuration-only changes."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Create Dedicated Repositories:"})," Set up one Git repository for GitOps resources and another for GitOps-managed application files (the apps GitOps will create)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Define Access Controls:"})," Implement role-based access control (RBAC) for each repository to enforce clear boundaries between application developers and deployment managers."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Automate Configuration Updates:"})," Configure your GitOps tool to pull configurations only from the dedicated configuration repository, ensuring separation and preventing unwanted triggers."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://argo-cd.readthedocs.io/en/stable/",children:"ArgoCD Documentation on Config and Code Separation"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://fluxcd.io/docs/",children:"Flux GitOps Workflow Guide"})}),"\n"]})]})}function d(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>a});var t=n(6540);const s={},o=t.createContext(s);function r(e){const i=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);